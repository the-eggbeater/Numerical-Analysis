# -*- coding: utf-8 -*-
"""Assignment_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ftx2MWi4n4gU6uXn0_0szB7Cr-KkKCtg

Question 1: Solving 1D Transport Equation (Convective + Diffusive Terms + Steady State)
"""

import numpy as np
import matplotlib.pyplot as plt
import time

'''
Our main objectives are:
I. Give a,b,c to for A and b + Create Unknown matrix phi
II. Perform UTM transformation on A and b
III. Perform Back-substitution on modified A and b to get solution array phi

'''

def process(n):        # Here n is the no. of grid points
  t_0 = time.time()
  # Discretization Eqns: Taylor Series Truncation

  L = 1
  h = L/(n-1)   # Length of Each Cell
  phi_0 = 1 # Boundary Values
  phi_L = 0 # Boundary Values

  # Assign the diagonal elements of the TDM
  a = 0.1/h**2 - 1/(2*h)
  b = -(0.2/h**2)
  c = 0.1/h**2 + 1/(2*h)

  # Form the TDM A

  A = np.zeros((n-2,n-2),dtype =object)

  for i in range(n-2):
    A[i][i] = b
  for i in range(n-3):
    A[i][i+1] = a
  for i in range(1,n-2):
    A[i][i-1] = c

  # Form the Constant RHS Matrix

  B = np.zeros((n-2,1),dtype=object)

  B[0][0] = -c*phi_0
  B[n-3][0] = -a*phi_L

  # Form the UTM and modified B

  U = A.copy()
  B_ = B.copy()

  for i in range(1,n-2):
    k = U[i][i-1]/U[i-1][i-1]
    U[i][i] -= k*U[i-1][i]
    B_[i][0] -= k*B_[i-1][0]

  # Perform Back Substitution
  phi = np.zeros((n-2,1), dtype=object)
  for i in range(n-3, -1, -1):  # n-3 to 0
      sum_ = sum(U[i][j] * phi[j][0] for j in range(i+1, n-2))
      phi[i][0] = (B_[i][0] - sum_) / U[i][i]

  t_end = time.time()

  x = np.linspace(0, L, n)                  # n nodes including the two boundaries
  phi_ext = np.hstack((1, phi.ravel(), 0))  # Extend phi with the boundary conditions

  plt.plot(x, phi_ext,'o--',label='numerical')
  plt.xlabel('x')
  plt.ylabel('phi')
  plt.title(f'Analytical v/s Theoretical Grid Size: {n}')


  # analytical solution
  phi_a = 1.0 - (np.exp(x/0.1) - 1.0)/(np.exp(L/0.1) - 1.0)

  plt.plot(x, phi_a,  label='analytical')
  plt.legend()
  plt.show()

  error = np.mean(abs(phi_a-phi_ext))
  t_process = t_end - t_0
  return error,t_process


e1,t1 = process(10)
e2,t2 = process(20)
e3,t3 = process(30)
e4,t4 = process(40)
e5,t5 = process(50)

N = [10,20,30,40,50]
n = np.log(N)
e = [e1/10,e2/20,e3/30,e4/40,e5/50]
t = [t1,t2,t3,t4,t5]
t_log = np.log(t)

plt.plot(n,e,'o--')
plt.xlabel("Grid Size log(N)")
plt.ylabel("Normalised Mean Error")
plt.title("Grid Size v/s Error")
plt.show()
plt.plot(n,t,'o--')
plt.xlabel("Grid Size log(N)")
plt.ylabel("Time Taken")
plt.title("Grid Size v/s Time")

plt.show()

# Compute local time complexities using central difference
k_local = np.zeros_like(N, dtype=float)

# Use central difference for interior points
for i in range(1, len(N)-1):
    k_local[i] = (t_log[i+1] - t_log[i-1]) / (n[i+1] - n[i-1])

# Use forward and backward difference at the ends
k_local[0] = (t_log[1] - t_log[0]) / (n[1] - n[0])
k_local[-1] = (t_log[-1] - t_log[-2]) / (n[-1] - n[-2])

# Print time complexity at each grid size
for i in range(len(N)):
    print(f"At grid size N = {N[i]}: Time complexity ≈ O(N^{k_local[i]:.2f})")

import numpy as np
import matplotlib.pyplot as plt

# ========== Discretisation of Domain ==========
n = 22
x = np.linspace(0, 1, n)
h = 1.0 / (n - 1)

# Initial guess (including boundary values)
phi_old = 1 - x
phi_old[0] = 1    # φ₀ = 1
phi_old[-1] = 0   # φ_L = 0

picard_iter = 1000
tol = 1e-10

# ========== TDMA (Thomas) Solver ==========
def tdma(A, B):
    """
    Solve A * ph = B where A is tridiagonal (shape (N,N)) and B has length N.
    Returns ph of length N.
    """
    N = len(B)
    # Extract the three diagonals:
    a = np.zeros(N)   # sub‐diagonal (offset −1)
    b = np.zeros(N)   # main diagonal (offset  0)
    c = np.zeros(N)   # super‐diagonal (offset +1)

    for i in range(N):
        b[i] = A[i, i]
        if i > 0:
            a[i] = A[i, i - 1]
        if i < N - 1:
            c[i] = A[i, i + 1]

    # Forward elimination
    for i in range(1, N):
        w = a[i] / b[i - 1]
        b[i] = b[i] - w * c[i - 1]
        B[i] = B[i] - w * B[i - 1]

    # Back substitution
    ph = np.zeros(N)
    ph[-1] = B[-1] / b[-1]
    for i in range(N - 2, -1, -1):
        ph[i] = (B[i] - c[i] * ph[i + 1]) / b[i]

    return ph

# ========== Picard Iteration ==========
for it in range(picard_iter):
    phi_1 = phi_old.copy()
    N = n - 2   # number of interior unknowns (exclude the two boundary nodes)

    # Preallocate coefficient arrays for the interior points
    a = np.zeros(N)
    b = np.zeros(N)

    # Compute a[j-1] and b[j-1] for j=1..n-2
    for j in range(1, n - 1):
        a[j - 1] = (1 + 0.5 * (phi_old[j] + phi_old[j - 1])) / (h * h)
        b[j - 1] = (1 + 0.5 * (phi_old[j] + phi_old[j + 1])) / (h * h)

    # Build the tridiagonal matrix A of size (N x N)
    A = np.zeros((N, N))
    #   main diagonal = −( a[k] + b[k] ) for k=0..N-1
    A[np.arange(N), np.arange(N)] = - (a + b)

    #   sub‐diagonal (i, i-1) for i=1..N-1 comes from a[1..N-1]
    #   that is A[i, i-1] = a[i], for i=1..N-1
    A[np.arange(1, N), np.arange(N - 1)] = a[1:]

    #   super‐diagonal (i, i+1) for i=0..N-2 comes from b[0..N-2]
    #   that is A[i, i+1] = b[i], for i=0..N-2
    A[np.arange(N - 1), np.arange(1, N)] = b[:N - 1]

    # Build the right‐hand side B of length N
    B = np.zeros(N)
    phi_0 = phi_old[0]     # left boundary
    phi_L = phi_old[-1]    # right boundary

    for i in range(N):
        # The equation for interior node j = i+1 in the original indexing:
        #   −(a[i] + b[i]) φ[i+1] + a[i] φ[i] + b[i] φ[i+2] = −x[i+1]
        # We move any boundary‐coupling terms into B:
        if i == 0:
            # i=0 corresponds to j=1, which has a[0]*φ₀ coupling
            B[i] = - x[i + 1] - a[0] * phi_0
        elif i == N - 1:
            # i=N-1 corresponds to j=n-2, which has b[N-1]*φ_L coupling
            B[i] = - x[i + 1] - b[N - 1] * phi_L
        else:
            B[i] = - x[i + 1]

    # Solve tridiagonal system for the N interior unknowns:
    phi_interior = tdma(A, B)

    # Re‐assemble full φ vector including boundaries:
    phi_1 = np.zeros(n)
    phi_1[0] = phi_0
    phi_1[-1] = phi_L
    phi_1[1:-1] = phi_interior

    # Check convergence in L2 norm on the interior points
    diff = phi_1 - phi_old
    res = np.linalg.norm(diff, ord=2)
    if res < tol:
        print(f"Solution converged at iteration {it}")
        phi_old = phi_1.copy()
        break

    phi_old = phi_1.copy()


#==============================================Q=0.1========================================================

# ========== Picard Iteration ==========
for it in range(picard_iter):
    phi_2 = phi_old.copy()
    N = n - 2   # number of interior unknowns (exclude the two boundary nodes)

    # Preallocate coefficient arrays for the interior points
    a = np.zeros(N)
    b = np.zeros(N)

    # Compute a[j-1] and b[j-1] for j=1..n-2
    for j in range(1, n - 1):
        a[j - 1] = (1 + 0.5 * (phi_old[j] + phi_old[j - 1])) / (h * h)
        b[j - 1] = (1 + 0.5 * (phi_old[j] + phi_old[j + 1])) / (h * h)

    # Build the tridiagonal matrix A of size (N x N)
    A = np.zeros((N, N))
    #   main diagonal = −( a[k] + b[k] ) for k=0..N-1
    A[np.arange(N), np.arange(N)] = - (a + b)

    #   sub‐diagonal (i, i-1) for i=1..N-1 comes from a[1..N-1]
    #   that is A[i, i-1] = a[i], for i=1..N-1
    A[np.arange(1, N), np.arange(N - 1)] = a[1:]

    #   super‐diagonal (i, i+1) for i=0..N-2 comes from b[0..N-2]
    #   that is A[i, i+1] = b[i], for i=0..N-2
    A[np.arange(N - 1), np.arange(1, N)] = b[:N - 1]

    # Build the right‐hand side B of length N
    B = np.zeros(N)
    phi_0 = phi_old[0]     # left boundary
    phi_L = phi_old[-1]    # right boundary

    for i in range(N):
        # The equation for interior node j = i+1 in the original indexing:
        #   −(a[i] + b[i]) φ[i+1] + a[i] φ[i] + b[i] φ[i+2] = −x[i+1]
        # We move any boundary‐coupling terms into B:
        if i == 0:
            # i=0 corresponds to j=1, which has a[0]*φ₀ coupling
            B[i] = - 1 - a[0] * phi_0
        elif i == N - 1:
            # i=N-1 corresponds to j=n-2, which has b[N-1]*φ_L coupling
            B[i] = - 1 - b[N - 1] * phi_L
        else:
            B[i] = - 1

    # Solve tridiagonal system for the N interior unknowns:
    phi_interior = tdma(A, B)

    # Re‐assemble full φ vector including boundaries:
    phi_2 = np.zeros(n)
    phi_2[0] = phi_0
    phi_2[-1] = phi_L
    phi_2[1:-1] = phi_interior

    # Check convergence in L2 norm on the interior points
    diff = phi_2 - phi_old
    res = np.linalg.norm(diff, ord=2)
    if res < tol:
        print(f"Solution converged at iteration {it}")
        phi_old = phi_2.copy()
        break

    phi_old = phi_2.copy()


#==============================================Q=0========================================================

# ========== Picard Iteration ==========
for it in range(picard_iter):
    phi_3 = phi_old.copy()
    N = n - 2   # number of interior unknowns (exclude the two boundary nodes)

    # Preallocate coefficient arrays for the interior points
    a = np.zeros(N)
    b = np.zeros(N)

    # Compute a[j-1] and b[j-1] for j=1..n-2
    for j in range(1, n - 1):
        a[j - 1] = (1 + 0.5 * (phi_old[j] + phi_old[j - 1])) / (h * h)
        b[j - 1] = (1 + 0.5 * (phi_old[j] + phi_old[j + 1])) / (h * h)

    # Build the tridiagonal matrix A of size (N x N)
    A = np.zeros((N, N))
    #   main diagonal = −( a[k] + b[k] ) for k=0..N-1
    A[np.arange(N), np.arange(N)] = - (a + b)

    #   sub‐diagonal (i, i-1) for i=1..N-1 comes from a[1..N-1]
    #   that is A[i, i-1] = a[i], for i=1..N-1
    A[np.arange(1, N), np.arange(N - 1)] = a[1:]

    #   super‐diagonal (i, i+1) for i=0..N-2 comes from b[0..N-2]
    #   that is A[i, i+1] = b[i], for i=0..N-2
    A[np.arange(N - 1), np.arange(1, N)] = b[:N - 1]

    # Build the right‐hand side B of length N
    B = np.zeros(N)
    phi_0 = phi_old[0]     # left boundary
    phi_L = phi_old[-1]    # right boundary

    for i in range(N):
        # The equation for interior node j = i+1 in the original indexing:
        #   −(a[i] + b[i]) φ[i+1] + a[i] φ[i] + b[i] φ[i+2] = −x[i+1]
        # We move any boundary‐coupling terms into B:
        if i == 0:
            # i=0 corresponds to j=1, which has a[0]*φ₀ coupling
            B[i] = 0 - a[0] * phi_0
        elif i == N - 1:
            # i=N-1 corresponds to j=n-2, which has b[N-1]*φ_L coupling
            B[i] = 0 - b[N - 1] * phi_L
        else:
            B[i] = 0

    # Solve tridiagonal system for the N interior unknowns:
    phi_interior = tdma(A, B)

    # Re‐assemble full φ vector including boundaries:
    phi_3 = np.zeros(n)
    phi_3[0] = phi_0
    phi_3[-1] = phi_L
    phi_3[1:-1] = phi_interior

    # Check convergence in L2 norm on the interior points
    diff = phi_3 - phi_old
    res = np.linalg.norm(diff, ord=2)
    if res < tol:
        print(f"Solution converged at iteration {it}")
        phi_old = phi_3.copy()
        break

    phi_old = phi_3.copy()



# Finally, plot the converged solution
plt.plot(x, phi_1, '-o',label="Q=0.1x")
plt.plot(x, phi_2, '-o',label="Q=0.1")
plt.plot(x, phi_3, '-o',label="Q=0")
plt.xlabel('x')
plt.ylabel(r'$\phi(x)$')
plt.title('Converged Picard Solution')
plt.legend()

"""Question 2: 2D Transport Equation (Diffusion + Source Term)


1.   Gauss Siedel Method
2.   Jacobi Method
3.   Successive Over Relaxation Method


"""

#------------------------------------Gauss-Siedel Iterative Method------------------------------------

import numpy as np
import matplotlib.pyplot as plt

# Discretisation of Domain
L = 1
n = 40
dx = L/(n-1)
dy = L/(n-1)

# Intitial Temperature Field
T = np.zeros((n,n))

tol = 1e-3


# The initial BCs are already set since the arrays have all elements 0

# Iterative Method: Gauss Siedel (We are updating the values in the same matrix)
for step in range(1000):
  T_old = T.copy()
  for j in range(1,n-1):
    for i in range(1,n-1):
      T[j,i]= ( (dy*dy)*(T[j,i+1]+T[j,i-1]) + (dx*dx)*(T[j+1,i]+T[j-1,i]) + (dx*dx*dy*dy) ) / (2 * (dx*dx + dy*dy))

  # Re-impose Boundary Conditions
  T[0,:]=0
  T[-1,:]=0
  T[:,0]=0
  T[:,-1]=0
  diff = T - T_old
  res = np.linalg.norm(diff, ord=2)
  if res<tol:
    print("Converged at",step)
    break

# Analytical Solution

x = np.linspace(0, L, 40)
y = np.linspace(0, L, 40)
X, Y = np.meshgrid(x, y)

# Initialize T(x, y)
T_ana = np.zeros_like(X)

# Truncation number: how many odd terms
N_terms = 15
odd = lambda k: 2*k + 1  # generates 1, 3, 5, ...

# Compute the analytical solution
for i in range(N_terms):
    n = odd(i)
    for j in range(N_terms):
        m = odd(j)
        coefficient = (1 / (n * m)) * (1 / (n**2 + m**2))
        T_ana += coefficient * np.sin(n * np.pi * X) * np.sin(m * np.pi * Y)

# Multiply by constant
T_ana *= 16 / (np.pi ** 4)

a=plt.contourf(x,y,T,levels=500)
plt.colorbar(a)

#---------------------------------------------Jacobi Iterative Method-------------------------------------

import numpy as np
import matplotlib.pyplot as plt

# Discretisation of Domain
L = 1
n = 40
dx = L/(n-1)
dy = L/(n-1)

# Intitial Temperature Field
T = np.zeros((n,n))

tol = 1e-3
iter = 1000

# The initial BCs are already set since the arrays have all elements 0

# Iterative Method: Jacobi Method
for step in range(iter):
  T_old = T.copy()
  T_new = T.copy()
  for j in range(1,n-1):
    for i in range(1,n-1):
      T_new[j,i]= ( (dy*dy)*(T[j,i+1]+T[j,i-1]) + (dx*dx)*(T[j+1,i]+T[j-1,i]) + (dx*dx*dy*dy) ) / (2 * (dx*dx + dy*dy))
  T = T_new
  # Re-impose Boundary Conditions
  T[0,:]=0
  T[-1,:]=0
  T[:,0]=0
  T[:,-1]=0

  if abs(np.max(T-T_old))<tol:
    print("Solution Converged at Iteration No: ",step+1)
    break

x = np.linspace(0, L, 40)
y = np.linspace(0, L, 40)
X, Y = np.meshgrid(x, y)

# Initialize T(x, y)
T_ana = np.zeros_like(X)

# Truncation number: how many odd terms
N_terms = 15
odd = lambda k: 2*k + 1  # generates 1, 3, 5, ...

# Compute the analytical solution
for i in range(N_terms):
    n = odd(i)
    for j in range(N_terms):
        m = odd(j)
        coefficient = (1 / (n * m)) * (1 / (n**2 + m**2))
        T_ana += coefficient * np.sin(n * np.pi * X) * np.sin(m * np.pi * Y)

# Multiply by constant
T_ana *= 16 / (np.pi ** 4)

#----------------------------------------SOR Iterative Method------------------------------------

import numpy as np
import matplotlib.pyplot as plt

# Discretisation of Domain
L = 1
n = 40
dx = L/(n-1)
dy = L/(n-1)

# Intitial Temperature Field
T = np.zeros((n,n))

tol = 1e-3
iter = 1000
w = 1.5
# The initial BCs are already set since the arrays have all elements 0

# Iterative Method: Successive Over Relaxation Method (We are updating the values in the same matrix)
for step in range(iter):
  T_old = T.copy()
  for j in range(1,n-1):
    for i in range(1,n-1):
      T[j,i]= T[j,i]*(1-w) + w*( (dy*dy)*(T[j,i+1]+T[j,i-1]) + (dx*dx)*(T[j+1,i]+T[j-1,i]) + (dx*dx*dy*dy) ) / (2 * (dx*dx + dy*dy))

  # Re-impose Boundary Conditions
  T[0,:]=0
  T[-1,:]=0
  T[:,0]=0
  T[:,-1]=0
  if abs(np.max(T-T_old))<tol:
    print("Solution Converged at Iteration No: ",step+1)
    break



x = np.linspace(0, L, 40)
y = np.linspace(0, L, 40)
X, Y = np.meshgrid(x, y)

# Initialize T(x, y)
T_ana = np.zeros_like(X)

# Truncation number: how many odd terms
N_terms = 15
odd = lambda k: 2*k + 1  # generates 1, 3, 5, ...

# Compute the analytical solution
for i in range(N_terms):
    n = odd(i)
    for j in range(N_terms):
        m = odd(j)
        coefficient = (1 / (n * m)) * (1 / (n**2 + m**2))
        T_ana += coefficient * np.sin(n * np.pi * X) * np.sin(m * np.pi * Y)

# Multiply by constant
T_ana *= 16 / (np.pi ** 4)

"""Q3. 2D Navier Stokes Equation (Steady State)"""

import numpy as np
import matplotlib.pyplot as plt

# Parameters
Lx, Ly = 1.0, 1.5
nx, ny = 129, 129                # grid points
dx = Lx / (nx - 1)             # Space Step in x
dy = Ly / (ny - 1)             # Space Step in y

Re = 100.0
nu = 1.0 / Re
rho = 1.0

# Initialize fields
u = np.zeros((ny, nx))
v = np.zeros((ny, nx))
p = np.zeros((ny, nx))

# Error Prevention
u_star = np.zeros_like(u)
v_star = np.zeros_like(v)
b = np.zeros_like(p)

# For Time Marching
dt = 0.001
n = 500
tol = 1e-6

# Initial Imposition of BCs
u[-1,:] = 1.0   # lid
u[0,:] = 0.0
u[:,0]= 0.0
u[:,-1]=0.0
v[-1,:] = 0.0
v[0,:] = 0.0
v[:,0]= 0.0
v[:,-1]=0.0

# For a time instant, calculate u_star
# Based on the u_star, find the RHS of the Pressure Poisson Relation
# Form a matrix and give pressure Boundary Calcualtions to solve for the Laplacian Pressure Term at t = n+1
# Then use the pressure field to get the Velocity Field at t = n+1

#Enter the time marching loop
for step in range(n):
  u_old = u.copy()     # t = n
  v_old = v.copy()     # t = n
  p_old = p.copy()     # t = n

#-------------------------------------------------------Step 1:----------------------------------------------------------------
  # Step 1: Approximate Velocity Field Calcualtion (u_star = u + dt*[-convective + nu*diffusive])
  for j in range(1,ny-1):
    for i in range(1,nx-1):
      du_dx = (u_old[j,i]-u_old[j,i-1])/(dx)        # Backward Difference
      du_dy = (u_old[j,i]-u_old[j-1,i])/(dy)
      dv_dx = (v_old[j,i]-v_old[j,i-1])/(dx)
      dv_dy = (v_old[j,i]-v_old[j-1,i])/(dy)

      # Convective Term (u*du/dx + v*du/dy)
      convective_u = u_old[j,i]*du_dx + v_old[j,i]*du_dy           # Backward Difference Method
      convective_v = u_old[j,i]*dv_dx + v_old[j,i]*dv_dy

      # Diffusive Term (d2u/dx^2 + d2u/dy^2)
      diffusive_u = (u_old[j,i+1]+u_old[j,i-1]-2*u_old[j,i])/(dx**2) + (u_old[j+1,i]+u_old[j-1,i]-2*u_old[j,i])/(dy**2)    # Central Difference Method
      diffusive_v = (v_old[j,i+1]+v_old[j,i-1]-2*v_old[j,i])/(dx**2) + (v_old[j+1,i]+v_old[j-1,i]-2*v_old[j,i])/(dy**2)

      # Approximate Velocity
      u_star[j,i] = u_old[j,i] + dt * ( -convective_u + nu*diffusive_u )
      v_star[j,i] = v_old[j,i] + dt * ( -convective_v + nu*diffusive_v )

  # Apply BCs on u_star, v_star
  u_star[ 0,:] = 0;    u_star[-1,:] = 1;    u_star[:, 0] = 0;    u_star[:,-1] = 0
  v_star[ 0,:] = 0;    v_star[-1,:] = 0;    v_star[:, 0] = 0;    v_star[:,-1] = 0

#-------------------------------------------------------Step 2:----------------------------------------------------------------

  # Step 2: Build RHS of Pressure Poisson Eqn from this obtained Velocity Field Approximation (Div(V) or du/dx + dv/dy)
  rhs = np.zeros([ny,nx])
  for j in range(1, ny-1):
    for i in range(1, nx-1):
      rhs[j,i] = rho * ((u_star[j, i+1] - u_star[j, i-1])/(2*dx) + (v_star[j+1, i] - v_star[j-1, i])/(2*dy)) /dt

#-------------------------------------------------------Step 3:----------------------------------------------------------------

  # Step 3: Find Pressure Field using this RHS matrix

  # Apply Gauss Siedel Solution Method to solve the matrix
  for _ in range(1000):  # simple Gauss–Seidel
    for j in range(1, ny-1):
      for i in range(1, nx-1):
          p[j,i] = (((p[j, i+1] + p[j, i-1]) * dy**2 + (p[j+1, i] + p[j-1, i]) * dx**2 - rhs[j,i] * dx**2 * dy**2)/ (2 * (dx**2 + dy**2)))
    # pressure BCs
    p[:, -1] = p[:, -2]
    p[:,  0] = p[:,  1]
    p[-1, :] = 0
    p[ 0, :] = p[ 1, :]

#-------------------------------------------------------Step 4:----------------------------------------------------------------

  # Step 4: Use the Pressure Field to calcualate the corrected Velocity Field such that Continuity is satisfied
  for j in range(1, ny-1):
    for i in range(1, nx-1):
      dpdx = (p[j, i+1] - p[j, i-1])/(2*dx)
      dpdy = (p[j+1, i] - p[j-1, i])/(2*dy)

      u[j,i] = u_star[j,i] - dt/rho * dpdx
      v[j,i] = v_star[j,i] - dt/rho * dpdy

  # Impose velocity BCs
  u[ 0,:] = 0;    u[-1,:] = 1;    u[:,  0] = 0;    u[:,-1] = 0
  v[ 0,:] = 0;    v[-1,:] = 0;    v[:,  0] = 0;    v[:,-1] = 0

#-------------------------------------------------------Step 5:----------------------------------------------------------------

  # Step 5: Convergence Check
  res = np.linalg.norm(u-u_old) + np.linalg.norm(v-v_old)
  if res < tol:
    print(f"Converged in {step} steps, residual={res:.2e}")
    break


X, Y = np.meshgrid(np.linspace(0,Lx,nx), np.linspace(0,Ly,ny))
plt.figure()
plt.streamplot(X, Y, u, v, density=2.0)
plt.title('Steady Streamlines')
plt.figure()
cnt = plt.contourf(X, Y, p, levels=50)
plt.colorbar(cnt, label='p')
plt.title('Steady Pressure')
plt.show()

"""Numba Integration"""

import numpy as np
import time
from numba import njit, prange

# ------------------------ #
#    1. PREDEFINE CONSTANTS
# ------------------------ #
Lx, Ly = 1.0, 1.5
nx, ny = 129, 129

dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

dx2 = dx * dx
dy2 = dy * dy
inv_dx  = 1.0 / dx
inv_dy  = 1.0 / dy
inv_2dx = 1.0 / (2.0 * dx)
inv_2dy = 1.0 / (2.0 * dy)
denom   = 2.0 * (dx2 + dy2)      # for Poisson update

Re = 100.0
nu = 1.0 / Re
rho = 1.0

dt = 0.001
n_steps = 5000
tol = 1e-6

# Pre‐build index ranges
i_min, i_max = 1, nx - 1
j_min, j_max = 1, ny - 1
range_i = range(i_min, i_max)
range_j = range(j_min, j_max)

# ------------------------ #
# 2. ALLOCATE ARRAYS ONCE
# ------------------------ #
u      = np.zeros((ny, nx))
v      = np.zeros((ny, nx))
p      = np.zeros((ny, nx))
u_star = np.zeros_like(u)
v_star = np.zeros_like(v)
rhs    = np.zeros_like(p)

# ------------------------ #
# 3. INITIAL BOUNDARY CONDITIONS
# ------------------------ #
u[-1, :] = 1.0    # moving lid (top boundary)
# (all other walls are already zero)

# ------------------------ #
# 4. NUMBA‐ACCELERATED KERNELS
# ------------------------ #

@njit
def compute_intermediate_velocity(u_old, v_old, u_star, v_star,
                                  nu, dt,
                                  inv_dx, inv_dy, dx2, dy2):
    """
    1) Compute u_star, v_star from u_old, v_old.
    2) Uses backward difference for convection and central difference for diffusion.
    """
    ny, nx = u_old.shape

    # Loop only over interior points
    for j in range(1, ny-1):
        # Cache row pointers for speed
        u_row   = u_old[j]
        u_row_m = u_old[j-1]
        u_row_p = u_old[j+1]
        v_row   = v_old[j]
        v_row_m = v_old[j-1]
        v_row_p = v_old[j+1]

        us_row = u_star[j]
        vs_row = v_star[j]

        for i in range(1, nx-1):
            # center values
            u_c = u_row[i]
            v_c = v_row[i]

            # neighbors in x and y
            u_l  = u_row[i-1]
            u_r  = u_row[i+1]
            u_b  = u_row_m[i]
            u_t  = u_row_p[i]

            v_l  = v_row[i-1]
            v_r  = v_row[i+1]
            v_b  = v_row_m[i]
            v_t  = v_row_p[i]

            # Convective (backward differences)
            du_dx = (u_c - u_l) * inv_dx
            du_dy = (u_c - u_b) * inv_dy
            dv_dx = (v_c - v_l) * inv_dx
            dv_dy = (v_c - v_b) * inv_dy

            conv_u = u_c * du_dx + v_c * du_dy
            conv_v = u_c * dv_dx + v_c * dv_dy

            # Diffusive (central differences)
            diff_u = ((u_r + u_l - 2.0*u_c) / dx2 +
                      (u_t + u_b - 2.0*u_c) / dy2)
            diff_v = ((v_r + v_l - 2.0*v_c) / dx2 +
                      (v_t + v_b - 2.0*v_c) / dy2)

            # Advance intermediate velocity
            us_row[i] = u_c + dt * (-conv_u + nu * diff_u)
            vs_row[i] = v_c + dt * (-conv_v + nu * diff_v)

    # Re‐apply BCs on u_star, v_star
    # (top lid: u_star = 1, others zero)
    for i in range(nx):
        u_star[0, i] = 0.0
        u_star[-1, i] = 1.0
        v_star[0, i] = 0.0
        v_star[-1, i] = 0.0
    for j in range(ny):
        u_star[j, 0] = 0.0
        u_star[j, -1] = 0.0
        v_star[j, 0] = 0.0
        v_star[j, -1] = 0.0


@njit
def build_rhs(u_star, v_star, rhs, rho, dt, inv_2dx, inv_2dy):
    """
    2) Build the RHS of the Pressure Poisson equation:
       rhs = (rho/dt) * (∂u_star/∂x + ∂v_star/∂y)
       using central differences.
    """
    ny, nx = u_star.shape

    for j in range(1, ny-1):
        us_row = u_star[j]
        us_row_l = u_star[j]    # same row
        us_row_r = u_star[j]    # same row
        vs_row_up = v_star[j+1]
        vs_row_dn = v_star[j-1]

        for i in range(1, nx-1):
            du_dx_star = (us_row[i+1] - us_row[i-1]) * inv_2dx
            dv_dy_star = (vs_row_up[i] - vs_row_dn[i]) * inv_2dy
            rhs[j, i] = rho * (du_dx_star + dv_dy_star) / dt

    # No need for boundary values of rhs; Poisson solver ignores them.


@njit
def solve_pressure_poisson(p, rhs, dx2, dy2, denom):
    """
    3) Gauss–Seidel iterations to solve ∇²p = rhs,
       with the same boundary conditions you had before.
       We do a fixed 1000 sweeps each time step.
    """
    ny, nx = p.shape

    for _ in range(1000):
        # Update interior points
        for j in range(1, ny-1):
            p_row   = p[j]
            p_row_m = p[j-1]
            p_row_p = p[j+1]

            for i in range(1, nx-1):
                p_row[i] = (
                    (p_row[i+1] + p_row[i-1]) * dy2
                    + (p_row_p[i]   + p_row_m[i])   * dx2
                    - rhs[j, i] * dx2 * dy2
                ) / denom

        # Re‐impose pressure BCs
        # dp/dx = 0 at left/right walls
        for j in range(ny):
            p[j, -1] = p[j, -2]
            p[j,  0] = p[j,  1]
        # p = 0 at top wall, dp/dy=0 at bottom
        for i in range(nx):
            p[-1, i] = p[-2, i]
            p[ 0, i] = p[ 1, i]


@njit
def correct_velocity(u_star, v_star, p, u, v, rho, dt, inv_2dx, inv_2dy):
    """
    4) Use pressure to correct intermediate velocities and
       re‐apply the velocity BCs.
    """
    ny, nx = u.shape

    for j in range(1, ny-1):
        p_row   = p[j]
        p_row_m = p[j-1]
        p_row_p = p[j+1]
        us_row  = u_star[j]
        vs_row  = v_star[j]
        u_row   = u[j]
        v_row   = v[j]

        for i in range(1, nx-1):
            dpdx = (p_row[i+1] - p_row[i-1]) * inv_2dx
            dpdy = (p_row_p[i]   - p_row_m[i])   * inv_2dy

            u_row[i] = us_row[i] - dt / rho * dpdx
            v_row[i] = vs_row[i] - dt / rho * dpdy

    # Re‐apply velocity BCs
    for i in range(nx):
        u[ 0, i] = 0.0
        u[-1, i] = 1.0
        v[ 0, i] = 0.0
        v[-1, i] = 0.0
    for j in range(ny):
        u[j,  0] = 0.0
        u[j, -1] = 0.0
        v[j,  0] = 0.0
        v[j, -1] = 0.0


# ------------------------ #
# 5. MAIN TIME‐MARCH LOOP
# ------------------------ #
start = time.time()

for step in range(n_steps):
    u_old = u.copy()
    v_old = v.copy()
    p_old = p.copy()

    # 1) Compute u_star, v_star
    compute_intermediate_velocity(
        u_old, v_old,
        u_star, v_star,
        nu, dt,
        inv_dx, inv_dy,
        dx2, dy2
    )

    # 2) Build RHS of Poisson
    build_rhs(
        u_star, v_star,
        rhs,
        rho, dt,
        inv_2dx, inv_2dy
    )

    # 3) Solve pressure Poisson
    solve_pressure_poisson(
        p, rhs,
        dx2, dy2, denom
    )

    # 4) Correct velocities
    correct_velocity(
        u_star, v_star,
        p, u, v,
        rho, dt,
        inv_2dx, inv_2dy
    )

    # 5) Check convergence
    res = np.linalg.norm(u - u_old) + np.linalg.norm(v - v_old)
    if res < tol:
        print(f"Converged in {step} steps, residual={res:.2e}")
        break

end = time.time()
print(f"Total runtime: {end - start:.2f} seconds")

X, Y = np.meshgrid(np.linspace(0,Lx,nx), np.linspace(0,Ly,ny))
plt.figure()
plt.streamplot(X, Y, u, v, density=2.0)
plt.title('Steady Streamlines')
plt.figure()
cnt = plt.contourf(X, Y, p, levels=50)
plt.colorbar(cnt, label='p')
plt.title('Steady Pressure')
plt.show()

"""Miscll.."""

import numpy as np
import time
from numba import njit, prange

# ------------------------ #
#    1. PREDEFINE CONSTANTS
# ------------------------ #
Lx, Ly = 1.0, 1.5
nx, ny = 129, 129

dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

dx2 = dx * dx
dy2 = dy * dy
inv_dx  = 1.0 / dx
inv_dy  = 1.0 / dy
inv_2dx = 1.0 / (2.0 * dx)
inv_2dy = 1.0 / (2.0 * dy)
denom   = 2.0 * (dx2 + dy2)      # for Poisson update

Re = 100.0
nu = 1.0 / Re
rho = 1.0

dt = 0.001
n_steps = 10000
tol = 1e-6

# Pre‐build index ranges
i_min, i_max = 1, nx - 1
j_min, j_max = 1, ny - 1
range_i = range(i_min, i_max)
range_j = range(j_min, j_max)

# ------------------------ #
# 2. ALLOCATE ARRAYS ONCE
# ------------------------ #
u      = np.zeros((ny, nx))
v      = np.zeros((ny, nx))
p      = np.zeros((ny, nx))
u_star = np.zeros_like(u)
v_star = np.zeros_like(v)
rhs    = np.zeros_like(p)

# ------------------------ #
# 3. INITIAL BOUNDARY CONDITIONS
# ------------------------ #
u[-1, :] = 1.0    # moving lid (top boundary)
# (all other walls are already zero)

# ------------------------ #
# 4. NUMBA‐ACCELERATED KERNELS
# ------------------------ #

@njit
def compute_intermediate_velocity(u_old, v_old, u_star, v_star,
                                  nu, dt,
                                  inv_dx, inv_dy, dx2, dy2):
    """
    1) Compute u_star, v_star from u_old, v_old.
    2) Uses backward difference for convection and central difference for diffusion.
    """
    ny, nx = u_old.shape

    # Loop only over interior points
    for j in range(1, ny-1):
        # Cache row pointers for speed
        u_row   = u_old[j]
        u_row_m = u_old[j-1]
        u_row_p = u_old[j+1]
        v_row   = v_old[j]
        v_row_m = v_old[j-1]
        v_row_p = v_old[j+1]

        us_row = u_star[j]
        vs_row = v_star[j]

        for i in range(1, nx-1):
            # center values
            u_c = u_row[i]
            v_c = v_row[i]

            # neighbors in x and y
            u_l  = u_row[i-1]
            u_r  = u_row[i+1]
            u_b  = u_row_m[i]
            u_t  = u_row_p[i]

            v_l  = v_row[i-1]
            v_r  = v_row[i+1]
            v_b  = v_row_m[i]
            v_t  = v_row_p[i]

            # Convective (backward differences)
            du_dx = (u_c - u_l) * inv_dx
            du_dy = (u_c - u_b) * inv_dy
            dv_dx = (v_c - v_l) * inv_dx
            dv_dy = (v_c - v_b) * inv_dy

            conv_u = u_c * du_dx + v_c * du_dy
            conv_v = u_c * dv_dx + v_c * dv_dy

            # Diffusive (central differences)
            diff_u = ((u_r + u_l - 2.0*u_c) / dx2 +
                      (u_t + u_b - 2.0*u_c) / dy2)
            diff_v = ((v_r + v_l - 2.0*v_c) / dx2 +
                      (v_t + v_b - 2.0*v_c) / dy2)

            # Advance intermediate velocity
            us_row[i] = u_c + dt * (-conv_u + nu * diff_u)
            vs_row[i] = v_c + dt * (-conv_v + nu * diff_v)

    # Re‐apply BCs on u_star, v_star
    # (top lid: u_star = 1, others zero)
    for i in range(nx):
        u_star[0, i] = 0.0
        u_star[-1, i] = 1.0
        v_star[0, i] = 0.0
        v_star[-1, i] = 0.0
    for j in range(ny):
        u_star[j, 0] = 0.0
        u_star[j, -1] = 0.0
        v_star[j, 0] = 0.0
        v_star[j, -1] = 0.0


@njit
def build_rhs(u_star, v_star, rhs, rho, dt, inv_2dx, inv_2dy):
    """
    2) Build the RHS of the Pressure Poisson equation:
       rhs = (rho/dt) * (∂u_star/∂x + ∂v_star/∂y)
       using central differences.
    """
    ny, nx = u_star.shape

    for j in range(1, ny-1):
        us_row = u_star[j]
        us_row_l = u_star[j]    # same row
        us_row_r = u_star[j]    # same row
        vs_row_up = v_star[j+1]
        vs_row_dn = v_star[j-1]

        for i in range(1, nx-1):
            du_dx_star = (us_row[i+1] - us_row[i-1]) * inv_2dx
            dv_dy_star = (vs_row_up[i] - vs_row_dn[i]) * inv_2dy
            rhs[j, i] = rho * (du_dx_star + dv_dy_star) / dt

    # No need for boundary values of rhs; Poisson solver ignores them.


@njit
def solve_pressure_poisson(p, rhs, dx2, dy2, denom):
    """
    3) Gauss–Seidel iterations to solve ∇²p = rhs,
       with the same boundary conditions you had before.
       We do a fixed 1000 sweeps each time step.
    """
    ny, nx = p.shape

    for _ in range(2000):
        # Update interior points
        for j in range(1, ny-1):
            p_row   = p[j]
            p_row_m = p[j-1]
            p_row_p = p[j+1]

            for i in range(1, nx-1):
                p_row[i] = (
                    (p_row[i+1] + p_row[i-1]) * dy2
                    + (p_row_p[i]   + p_row_m[i])   * dx2
                    - rhs[j, i] * dx2 * dy2
                ) / denom

        # Re‐impose pressure BCs
        # dp/dx = 0 at left/right walls
        for j in range(ny):
            p[j, -1] = p[j, -2]
            p[j,  0] = p[j,  1]
        # p = 0 at top wall, dp/dy=0 at bottom
        for i in range(nx):
            p[-1, i] = p[-2, i]
            p[ 0, i] = p[ 1, i]


@njit
def correct_velocity(u_star, v_star, p, u, v, rho, dt, inv_2dx, inv_2dy):
    """
    4) Use pressure to correct intermediate velocities and
       re‐apply the velocity BCs.
    """
    ny, nx = u.shape

    for j in range(1, ny-1):
        p_row   = p[j]
        p_row_m = p[j-1]
        p_row_p = p[j+1]
        us_row  = u_star[j]
        vs_row  = v_star[j]
        u_row   = u[j]
        v_row   = v[j]

        for i in range(1, nx-1):
            dpdx = (p_row[i+1] - p_row[i-1]) * inv_2dx
            dpdy = (p_row_p[i]   - p_row_m[i])   * inv_2dy

            u_row[i] = us_row[i] - dt / rho * dpdx
            v_row[i] = vs_row[i] - dt / rho * dpdy

    # Re‐apply velocity BCs
    for i in range(nx):
        u[ 0, i] = 0.0
        u[-1, i] = 1.0
        v[ 0, i] = 0.0
        v[-1, i] = 0.0
    for j in range(ny):
        u[j,  0] = 0.0
        u[j, -1] = 0.0
        v[j,  0] = 0.0
        v[j, -1] = 0.0


# ------------------------ #
# 5. MAIN TIME‐MARCH LOOP
# ------------------------ #
start = time.time()

for step in range(n_steps):
    u_old = u.copy()
    v_old = v.copy()
    p_old = p.copy()

    # 1) Compute u_star, v_star
    compute_intermediate_velocity(
        u_old, v_old,
        u_star, v_star,
        nu, dt,
        inv_dx, inv_dy,
        dx2, dy2
    )

    # 2) Build RHS of Poisson
    build_rhs(
        u_star, v_star,
        rhs,
        rho, dt,
        inv_2dx, inv_2dy
    )

    # 3) Solve pressure Poisson
    solve_pressure_poisson(
        p, rhs,
        dx2, dy2, denom
    )

    # 4) Correct velocities
    correct_velocity(
        u_star, v_star,
        p, u, v,
        rho, dt,
        inv_2dx, inv_2dy
    )

    # 5) Check convergence
    res = np.linalg.norm(u - u_old) + np.linalg.norm(v - v_old)
    if res < tol:
        print(f"Converged in {step} steps, residual={res:.2e}")
        break

end = time.time()
print(f"Total runtime: {end - start:.2f} seconds")

X, Y = np.meshgrid(np.linspace(0,Lx,nx), np.linspace(0,Ly,ny))
plt.figure()
plt.streamplot(X, Y, u, v, density=2.0)
plt.title('Steady Streamlines')
plt.figure()
cnt = plt.contourf(X, Y, p, levels=50)
plt.colorbar(cnt, label='p')
plt.title('Steady Pressure')
plt.show()

import numpy as np
import time
from numba import njit, prange

# ------------------------ #
#    1. PREDEFINE CONSTANTS
# ------------------------ #
Lx, Ly = 1.0, 1.0
nx, ny = 129, 129

dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

dx2 = dx * dx
dy2 = dy * dy
inv_dx  = 1.0 / dx
inv_dy  = 1.0 / dy
inv_2dx = 1.0 / (2.0 * dx)
inv_2dy = 1.0 / (2.0 * dy)
denom   = 2.0 * (dx2 + dy2)      # for Poisson update

Re = 100.0
nu = 1.0 / Re
rho = 1.0

dt = 0.001
n_steps = 10000
tol = 1e-6

# Pre‐build index ranges
i_min, i_max = 1, nx - 1
j_min, j_max = 1, ny - 1
range_i = range(i_min, i_max)
range_j = range(j_min, j_max)

# ------------------------ #
# 2. ALLOCATE ARRAYS ONCE
# ------------------------ #
u      = np.zeros((ny, nx))
v      = np.zeros((ny, nx))
p      = np.zeros((ny, nx))
u_star = np.zeros_like(u)
v_star = np.zeros_like(v)
rhs    = np.zeros_like(p)

# ------------------------ #
# 3. INITIAL BOUNDARY CONDITIONS
# ------------------------ #
u[-1, :] = 1.0    # moving lid (top boundary)
# (all other walls are already zero)

# ------------------------ #
# 4. NUMBA‐ACCELERATED KERNELS
# ------------------------ #

@njit
def compute_intermediate_velocity(u_old, v_old, u_star, v_star,
                                  nu, dt,
                                  inv_dx, inv_dy, dx2, dy2):
    """
    1) Compute u_star, v_star from u_old, v_old.
    2) Uses backward difference for convection and central difference for diffusion.
    """
    ny, nx = u_old.shape

    # Loop only over interior points
    for j in range(1, ny-1):
        # Cache row pointers for speed
        u_row   = u_old[j]
        u_row_m = u_old[j-1]
        u_row_p = u_old[j+1]
        v_row   = v_old[j]
        v_row_m = v_old[j-1]
        v_row_p = v_old[j+1]

        us_row = u_star[j]
        vs_row = v_star[j]

        for i in range(1, nx-1):
            # center values
            u_c = u_row[i]
            v_c = v_row[i]

            # neighbors in x and y
            u_l  = u_row[i-1]
            u_r  = u_row[i+1]
            u_b  = u_row_m[i]
            u_t  = u_row_p[i]

            v_l  = v_row[i-1]
            v_r  = v_row[i+1]
            v_b  = v_row_m[i]
            v_t  = v_row_p[i]

            # Convective (backward differences)
            du_dx = (u_c - u_l) * inv_dx
            du_dy = (u_c - u_b) * inv_dy
            dv_dx = (v_c - v_l) * inv_dx
            dv_dy = (v_c - v_b) * inv_dy

            conv_u = u_c * du_dx + v_c * du_dy
            conv_v = u_c * dv_dx + v_c * dv_dy

            # Diffusive (central differences)
            diff_u = ((u_r + u_l - 2.0*u_c) / dx2 +
                      (u_t + u_b - 2.0*u_c) / dy2)
            diff_v = ((v_r + v_l - 2.0*v_c) / dx2 +
                      (v_t + v_b - 2.0*v_c) / dy2)

            # Advance intermediate velocity
            us_row[i] = u_c + dt * (-conv_u + nu * diff_u)
            vs_row[i] = v_c + dt * (-conv_v + nu * diff_v)

    # Re‐apply BCs on u_star, v_star
    # (top lid: u_star = 1, others zero)
    for i in range(nx):
        u_star[0, i] = 0.0
        u_star[-1, i] = 1.0
        v_star[0, i] = 0.0
        v_star[-1, i] = 0.0
    for j in range(ny):
        u_star[j, 0] = 0.0
        u_star[j, -1] = 0.0
        v_star[j, 0] = 0.0
        v_star[j, -1] = 0.0


@njit
def build_rhs(u_star, v_star, rhs, rho, dt, inv_2dx, inv_2dy):
    """
    2) Build the RHS of the Pressure Poisson equation:
       rhs = (rho/dt) * (∂u_star/∂x + ∂v_star/∂y)
       using central differences.
    """
    ny, nx = u_star.shape

    for j in range(1, ny-1):
        us_row = u_star[j]
        us_row_l = u_star[j]    # same row
        us_row_r = u_star[j]    # same row
        vs_row_up = v_star[j+1]
        vs_row_dn = v_star[j-1]

        for i in range(1, nx-1):
            du_dx_star = (us_row[i+1] - us_row[i-1]) * inv_2dx
            dv_dy_star = (vs_row_up[i] - vs_row_dn[i]) * inv_2dy
            rhs[j, i] = rho * (du_dx_star + dv_dy_star) / dt

    # No need for boundary values of rhs; Poisson solver ignores them.


@njit
def solve_pressure_poisson(p, rhs, dx2, dy2, denom):
    """
    3) Gauss–Seidel iterations to solve ∇²p = rhs,
       with the same boundary conditions you had before.
       We do a fixed 1000 sweeps each time step.
    """
    ny, nx = p.shape

    for _ in range(2000):
        # Update interior points
        for j in range(1, ny-1):
            p_row   = p[j]
            p_row_m = p[j-1]
            p_row_p = p[j+1]

            for i in range(1, nx-1):
                p_row[i] = (
                    (p_row[i+1] + p_row[i-1]) * dy2
                    + (p_row_p[i]   + p_row_m[i])   * dx2
                    - rhs[j, i] * dx2 * dy2
                ) / denom

        # Re‐impose pressure BCs
        # dp/dx = 0 at left/right walls
        for j in range(ny):
            p[j, -1] = p[j, -2]
            p[j,  0] = p[j,  1]
        # p = 0 at top wall, dp/dy=0 at bottom
        for i in range(nx):
            p[-1, i] = p[-2, i]
            p[ 0, i] = p[ 1, i]


@njit
def correct_velocity(u_star, v_star, p, u, v, rho, dt, inv_2dx, inv_2dy):
    """
    4) Use pressure to correct intermediate velocities and
       re‐apply the velocity BCs.
    """
    ny, nx = u.shape

    for j in range(1, ny-1):
        p_row   = p[j]
        p_row_m = p[j-1]
        p_row_p = p[j+1]
        us_row  = u_star[j]
        vs_row  = v_star[j]
        u_row   = u[j]
        v_row   = v[j]

        for i in range(1, nx-1):
            dpdx = (p_row[i+1] - p_row[i-1]) * inv_2dx
            dpdy = (p_row_p[i]   - p_row_m[i])   * inv_2dy

            u_row[i] = us_row[i] - dt / rho * dpdx
            v_row[i] = vs_row[i] - dt / rho * dpdy

    # Re‐apply velocity BCs
    for i in range(nx):
        u[ 0, i] = 0.0
        u[-1, i] = 1.0
        v[ 0, i] = 0.0
        v[-1, i] = 0.0
    for j in range(ny):
        u[j,  0] = 0.0
        u[j, -1] = 0.0
        v[j,  0] = 0.0
        v[j, -1] = 0.0


# ------------------------ #
# 5. MAIN TIME‐MARCH LOOP
# ------------------------ #
start = time.time()

for step in range(n_steps):
    u_old = u.copy()
    v_old = v.copy()
    p_old = p.copy()

    # 1) Compute u_star, v_star
    compute_intermediate_velocity(
        u_old, v_old,
        u_star, v_star,
        nu, dt,
        inv_dx, inv_dy,
        dx2, dy2
    )

    # 2) Build RHS of Poisson
    build_rhs(
        u_star, v_star,
        rhs,
        rho, dt,
        inv_2dx, inv_2dy
    )

    # 3) Solve pressure Poisson
    solve_pressure_poisson(
        p, rhs,
        dx2, dy2, denom
    )

    # 4) Correct velocities
    correct_velocity(
        u_star, v_star,
        p, u, v,
        rho, dt,
        inv_2dx, inv_2dy
    )

    # 5) Check convergence
    res = np.linalg.norm(u - u_old) + np.linalg.norm(v - v_old)
    if res < tol:
        print(f"Converged in {step} steps, residual={res:.2e}")
        break

end = time.time()
print(f"Total runtime: {end - start:.2f} seconds")

X, Y = np.meshgrid(np.linspace(0,Lx,nx), np.linspace(0,Ly,ny))
plt.figure()
plt.streamplot(X, Y, u, v, density=2.0)
plt.title('Steady Streamlines')
plt.figure()
cnt = plt.contourf(X, Y, p, levels=50)
plt.colorbar(cnt, label='p')
plt.title('Steady Pressure')
plt.show()

# ─── 6. EXTRACT & COMPARE WITH BENCHMARK ───────────────────────────────────
# (a) Find the x‐index of the vertical centerline:
i_mid = nx // 2   # for nx=129, this is 64 (zero‐based)

# (b) Extract your computed u‐velocity along x = Lx/2:
#     We assume u.shape == (ny, nx) with first index = y, second = x.
u_center = u[:, i_mid]   # length = ny

# (c) Build the “benchmark” arrays for Re = 100 exactly as in your table:
#     These are the (1-based) grid‐point numbers from the image table:
grid_pts_1based = np.array([
    129, 126, 125, 124, 123, 110,  95,  80,  65,
     59,  37,  23,  14,  10,   9,   8,   1
], dtype=np.int64)

# Convert to 0‐based indices:
grid_idx0 = grid_pts_1based - 1   # now ranging 0..128

# Corresponding “u_bench” values (Re = 100) from the same rows:
u_bench = np.array([
    +1.00000,
    +0.84123,
    +0.78871,
    +0.73722,
    +0.68717,
    +0.23151,
    +0.00332,
    -0.13641,
    -0.20581,
    -0.21090,
    -0.15662,
    -0.10150,
    -0.06434,
    -0.04775,
    -0.04192,
    -0.03717,
    +0.00000
], dtype=np.float64)

# (d) Compute the physical y‐coordinate at each zero‐based index:
#     Recall  Δy = Ly/(ny−1).  Here Ly=1.0, ny=129, so Δy = 1/128 = 0.0078125.
dy = Ly / (ny - 1)
y_bench = grid_idx0.astype(np.float64) * dy

# (e) Pick out your numerical u‐values at exactly those same j‐indices:
u_num_at_bench = u_center[grid_idx0]

# (f) Compute the difference:
delta = u_num_at_bench - u_bench

# (g) Print a neat comparison table:
print("\nComparison of u‐velocity along centerline (Re = 100):")
print(f"{'j (0‐based)':>10s}   {'y_j':>8s}   {'u_bench':>8s}   {'u_num':>8s}   {'Δu (num−bench)':>16s}")
print("-" * 60)
for j0, yj, ub, un, d in zip(grid_idx0, y_bench, u_bench, u_num_at_bench, delta):
    print(f"{j0:10d}   {yj:8.5f}   {ub:8.5f}   {un:8.5f}   {d:16.5e}")

# (h) Optional: overlay a quick plot
import matplotlib.pyplot as plt
plt.figure(figsize=(4,6))
plt.plot(u_bench, y_bench, 'ro-', label='Benchmark (Re=100)')
plt.plot(u_num_at_bench, y_bench, 'bx--', label='u‐centerline')
plt.xlabel('u‐velocity')
plt.ylabel('y')
plt.title('Centerline comparison @ Re=100')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# (a) Find the zero‐based row index j_mid corresponding to y = Ly/2
j_mid = ny // 2   # for ny=129, this equals 64 (zero‐based)

# (b) Extract the computed v‐velocity along y = Ly/2:
#     We assume v[j,i] = v(x_i, y_j).  So:
v_center = v[j_mid, :]   # length = nx

# (c) Build the “benchmark” arrays from Table II (Re = 100):
#     The 1‐based “grid point no.” along the horizontal line (from the left column):
grid_pts_1based_v = np.array([
    129, 125, 124, 123, 122, 117, 111, 104,  65,
     31,  30,  21,  13,  11,  10,   9,   1
], dtype=np.int64)

# Convert to 0‐based indices for Python:
grid_idx0_v = grid_pts_1based_v - 1   # e.g. 129→128, 125→124, …, 1→0

# Corresponding v‐benchmarks at Re = 100 (from the Re=100 column of Table II):
v_bench = np.array([
     0.00000,
    -0.05906,
    -0.07391,
    -0.08864,
    -0.10313,
    -0.16914,
    -0.22445,
    -0.24533,
    +0.05454,
    +0.17527,
    +0.17507,
    +0.16503,
    +0.12317,
    +0.10890,
    +0.10091,
    +0.09233,
     0.00000
], dtype=np.float64)

# (d) Compute the physical x‐coordinate at each zero‐based index:
dx = Lx / (nx - 1)        # = 1/(129-1) = 1/128 = 0.0078125
x_bench = grid_idx0_v.astype(np.float64) * dx

# (e) Pick out your numerical v‐values at exactly those same i‐indices:
v_num_at_bench = v_center[grid_idx0_v]

# (f) Compute the difference Δv = v_num − v_bench
delta_v = v_num_at_bench - v_bench

# (g) Print out a comparison table
print("\nComparison of v‐velocity along horizontal centerline (Re = 100):")
print(f"{'i (0‐based)':>10s}   {'x_i':>8s}   {'v_bench':>8s}   {'v_num':>8s}   {'Δv (num−bench)':>16s}")
print("-" * 60)
for i0, xi, vb, vn, dv in zip(grid_idx0_v, x_bench, v_bench, v_num_at_bench, delta_v):
    print(f"{i0:10d}   {xi:8.5f}   {vb:8.5f}   {vn:8.5f}   {dv:16.5e}")

# (h) Optional: overlay a quick plot
plt.figure(figsize=(6,4))
plt.plot(x_bench, v_bench, 'ro-', label='Benchmark v (Re=100)')
plt.plot(x_bench, v_num_at_bench, 'bx--', label='v_centerline')
plt.xlabel('x')
plt.ylabel('v‐velocity')
plt.title('Horizontal‐centerline comparison, Re = 100')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()